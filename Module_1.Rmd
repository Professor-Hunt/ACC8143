---
title: "Module 1"
description: |
  Introduction to machine learning
output: 
  distill::distill_article:
    toc: true
    toc_depth: 3
---

# Game Plan

This module provides the basis for the rest of the course by introducing the basic concepts behind machine learning, and, specifically, how to perform machine learning by using RStudio and the CARET R package. First, you will learn how machine learning and artificial intelligence are disrupting businesses. Next, you will learn about the basic types of machine learning and how to leverage these algorithms in a R script. Third, you will learn how linear regression can be considered a machine learning problem with parameters that must be determined computationally by minimizing a *cost* function. Finally, you will learn about neighbor-based algorithms, including the k-nearest neighbor algorithm, which can be used for both classification and regression tasks.

# Objectives

### **By the end of this module, you should be able to:**

-   articulate the different types of machine learning algorithms and provide examples where each type might be applied within the Accounting profession,

-   describe the challenges in cleaning and pre-processing data,

-   apply the Caret Package to perform basic machine learning tasks,

-   understand the importance of a *cost* function and the importance of minimizing this functions,

-   perform general linear regression by using the Caret Package, and

-   apply the k-nearest neighbor algorithm for both classification and regression tasks.

## **Artificial Intelligence and Accountancy**

This lesson explores the fundamentals of machine learning and artificial intelligence and how these tools are being used in accountancy and business in general.

### Interesting Articles

[How is accountancy and finance world using artificial intelligence](https://www.icas.com/ca-today-news/how-accountancy-and-finance-are-using-artificial-intelligence)

[Financial Statement Audits](http://ww2.cfo.com/auditing/2017/02/artificial-intelligence-audits/)

1.  What is the growing role artificial intelligence (and by association, machine learning) play in modern accounting?

2.  What does the impact technology plays in shaping careers in modern accountancy?

3.  How is artificial intelligence impacting financial auditing?

## **Introduction to Machine Learning**[^1]

[^1]: The is borrowed content from <https://insights.principa.co.za/4-types-of-data-analytics-descriptive-diagnostic-predictive-prescriptive>

![](images/4-types-of-data-analytics-principa.png){width="100%"}

*Your most important skill will be your ability to translate data into insights that are clear and meaningful to a stakeholder.*

## **The Four Types of Data Analysis are:**

### **1. Descriptive Analytics: What is happening?**

This is the most common of all forms. In business, it provides the analyst with a view of key metrics and measures within the company.

An example of this could be a monthly profit and loss statement. Similarly, an analyst could have data on a large population of customers. Understanding demographic information on their customers (e.g. 30% of our customers are self-employed) would be categorised as "descriptive analytics". Utilising useful visualisation tools enhances the message of descriptive analytics.

### **2. Diagnostic Analytics: Why is it happening?**

This is the next step in complexity in data analytics is descriptive analytics. On the assessment of the descriptive data, diagnostic analytical tools will empower an analyst to drill down and in so doing isolate the root-cause of a problem.

Well-designed business information (BI) dashboards incorporating reading of time-series data (i.e. data over multiple successive points in time) and featuring filters and drill down capability allow for such analysis.

### **3. Predictive Analytics: What is likely to happen?**

Predictive analytics is all about forecasting. Whether it's the likelihood of an event happening in future, forecasting a quantifiable amount or estimating a point in time at which something might happen - these are all done through predictive models.

Predictive models typically utilise a variety of variable data to make the prediction. The variability of the component data will have a relationship with what it is likely to predict (e.g. the older a person, the more susceptible they are to a heart-attack -- we would say that age has a linear correlation with heart-attack risk). These data are then compiled together into a score or prediction.

In a world of significant uncertainty, being able to predict allows one to make better decisions. Predictive models are some of the most important utilised across many fields.

[Common Issues with Prediction](https://insights.principa.co.za/the-top-predictive-analytics-pitfalls-to-avoid)

### **4. Prescriptive Analytics: What do I need to do?**

The next step up regarding value and complexity is the prescriptive model.¬† The prescriptive model utilises an understanding of what has happened, why it has happened and a variety of "what-might-happen" analysis to help the user determine the best course of action to take. A prescriptive analysis is typically not just with one individual response but is, in fact, a host of other actions.

An excellent example of this is a traffic application helping you choose the best route home and taking into account the distance of each route, the speed at which one can travel on each road and, crucially, the current traffic constraints.

Another example might be producing an exam time-table such that no students have clashing schedules.

## Getting our hands dirty

As a field, [machine learning](https://en.wikipedia.org/wiki/Machine_learning) is both expansive and mathematically complex. From deriving simple linear relationships via regression analysis to finding clusters of data points in an N-dimensional space; statistical and machine learning techniques can take years to fully master. However, given the short time available in this course, we will take the simpler approach of demonstrating several commonly used approaches in order to both introduce the fundamental concepts in machine learning and the methodology we will use in RStudio to apply these concepts to actual data. For the latter, we will use the standard machine learning library in R, which is the *Caret Package*.

We will demonstrate the four main tasks of machine learning: classification, regression, dimensional reduction, and clustering. Note that this module is simply an introduction to these topics, we will explore these and other areas in more detail throughout this course. Finally, we will discuss how to persist machine learning models.

### Set up

Make sure you have the caret package installed.

```{r, echo=TRUE, eval=FALSE}

install.packages("caret")
```

Run your libraries

```{r,echo=TRUE,warning=FALSE,message=FALSE}
library(tidyverse)
library(caret)
```

The first steps in any data analytics effort, once the business goal has been defined, are to understand and prepare the data of interest. For example, the [**Cross Industry Standard Process for Data Mining**](https://en.wikipedia.org/wiki/Cross_Industry_Standard_Process_for_Data_Mining) or (**CRISP-DM**) starts with the *Business Understanding* step, immediately followed by the *Data Understanding* and *Data Preparation* steps. For machine learning analyses, these latter two steps require loading the data into our notebook, exploring the data either systematically or in a cumulative sense to understand the typical features for different instances. We also can generate descriptive statistical summaries and visualizations, such as a *pair plot*, to understand the data in full. Finally, we will need to clean the data to properly account for missing data, data that are incomplete or formatted incorrectly, or to generate meta-features (such as a date-time) from existing features.

![](images/800px-CRISP-DM_Process_Diagram.png){width="100%"}

For this module, we will focus on a single, simple data set, the standard *Iris* dataset, which is included by default. Note that given a data set, such as the *Iris* data, we have rows, which correspond to different instances (e.g., different flowers), and columns, which correspond to different features of the instances (e.g., different measurements of the flowers). To understand the data, we first load this data into RStudio, before looking at several instances from the data. Next, we will group the data by species to explore cumulative quantities, before extracting a statistical summary of the entire data set. Finally, we will generate a pair plot to visually explore the data. Since this data has already been cleaned (and only consists of four features) we will not need to perform additional tasks.\

Load the data

```{r, echo=TRUE}
#load the data
iris<-iris
```

The data set consists of 150 total measurements of three different types of Iris flowers, equally divided between three classes: Iris setosa, Iris versicolor, and Iris virginica. Before proceeding, we can examine the DataFrame that contains these data to view typical instances, to see a cumulative summary, and a brief statistical summary.

```{r, echo=TRUE}
#examine the top 5 rows
head(iris,5)

#view the whole dataset
knitr::kable(iris)%>%
  kableExtra::kable_styling("striped")%>%
  kableExtra::scroll_box(width = "100%",height="300px")
```

```{r,echo=TRUE}
#examine grouped data
iris%>%
  group_by(Species)%>%
  summarise(count=n())
```

```{r,echo=TRUE}
# Get descriptive statistics
summary(iris)

```

Another handy package

```{r,echo=TRUE,eval=FALSE}
install.packages("psych")

```

```{r,echo=TRUE}
psych::describe(iris)

# ?psych::describe

```

Look up what mad, se, skewness, and kurtosis is... üïµÔ∏è

------------------------------------------------------------------------

As demonstrated by the output from the previous code cells, our test data matches our expectations (note that the full Iris data set is listed on [Wikipedia](https://en.wikipedia.org/wiki/Iris_flower_data_set)). These data consist of three types, each with fifty instances, and every row has four measured features (i.e., attributes). The four primary features of the data are *Sepal Length*, *Sepal Width*, *Petal Length*, and *Petal Width*. In simple terms, petals are the showy, colorful part of the Iris flower, while the sepals provide protection and support for the petals.

In addition, our cursory exploration of the DataFrame indicated the data are clean. One simple way to verify this is that the *count* is the same for every feature, and the descriptive statistics (e.g., *min*, *max*, and *mean*) are all numerical. If we had missing or bad data in our DataFrame, these measures would generally indicate the problem. If there were missing data, we could drop any instance with missing data by using the `na.omit` method, or alternatively insert a value by using [`mutate`](https://towardsdatascience.com/data-cleaning-with-r-and-the-tidyverse-detecting-missing-values-ea23c519bc62) . An alternative, and powerful, technique for handling missing data is known as **imputing**, where we apply machine learning[^2] to generate *realistic* values for any missing data. This approach will be demonstrated in a subsequent module.

[^2]: This is a narrow definition because you can also impute with summary statistics such as mean or median.

At this point, we have loaded our data, and verified the data are clean. The next step is to visualize the relationships between the different features in our data.

Lets use another package üòÜ

```{r, echo=TRUE,eval=FALSE}
install.packages("GGally")
```

Look at me üëÄ [ggpairs function](https://r-charts.com/correlation/ggpairs/) üëÄ

```{r,echo=TRUE,warning=FALSE,message=FALSE}
GGally::ggpairs(iris)
```

```{r,echo=TRUE,warning=FALSE}
GGally::ggpairs(iris, aes(color = Species, alpha = 0.5))
```

These figures indicate that the three Iris species cluster naturally in these dimensions, with minimal overlap. As a result, these data provide an excellent test for different machine learning algorithms.

First, however, we will generate one [scatter plot](https://moderndive.com/2-viz.html#scatterplots) that displays a larger version of the *Sepal Width* versus *Petal Width* scatter plot to highlight the inherent structure in these data. Furthermore, we will refer back to this plot in later analyses in this Module.

```{r, echo=TRUE}
#crash course in plots?
ggplot(data=iris,mapping = aes(x=Sepal.Width,y=Petal.Width,color=Species))+geom_point(alpha=0.5)
```

<details>

<summary>

### Side Note...Other plots üôà

</summary>

<p>

[Line Graph](https://moderndive.com/2-viz.html#linegraphs)

```{r,echo=TRUE}
#line graph..this is a TERRIBLE example...
#ask me why
iris.setosa<-iris%>%
  filter(Species=="setosa")%>%
  distinct(Sepal.Width,.keep_all = TRUE)

ggplot(data=iris.setosa,mapping = aes(x=Sepal.Width,y=Sepal.Length))+geom_line()

```

[Histograms](https://moderndive.com/2-viz.html#histograms)

```{r,echo=TRUE}
ggplot(data=iris,mapping = aes(x=Sepal.Length,color=Species))+geom_histogram()
```

[Boxplots](https://moderndive.com/2-viz.html#boxplots)

```{r,echo=TRUE}
ggplot(data=iris,mapping = aes(x=Species,y=Sepal.Length))+geom_boxplot()
```

[Bar plots](https://moderndive.com/2-viz.html#geombar)

```{r,echo=TRUE}
ggplot(data=iris,mapping = aes(x=Species))+geom_bar()
```

</p>

</details>

# Introducing Machine Learning

Machine learning algorithms can be classified by the method in which they are constructed. [Supervised learning](https://en.wikipedia.org/wiki/Supervised_learning) methods use training data to build a model, which is subsequently applied to additional data. On the other hand, [unsupervised learning](https://en.wikipedia.org/wiki/Unsupervised_learning) methods seek relationships among data points that can be leveraged to construct a model that is subsequently applied to the data of interest. In some cases, training data are used to validate the effectiveness of an unsupervised method, or perhaps to provide some level of supervision, which is known as [semi-supervised learning](https://en.wikipedia.org/wiki/Semi-supervised_learning).

More recently, additional types of learning have been developed. First, [transfer learning](https://en.wikipedia.org/wiki/Transfer_learning) extends a model trained on a previous data set to new, related data. This can be viewed as learning by analogy, which is similar to how humans learn. Second, [reinforcement learning](https://en.wikipedia.org/wiki/Reinforcement_learning#Current_research) is a technique that explores how agents should behave within an environment by maximizing a cumulative reward. Finally, [deep learning](https://en.wikipedia.org/wiki/Deep_learning) applies artificial neural networks that have multiple hidden layers to complex tasks, often with spectacular success in areas from image recognition to natural language processing.

Broadly speaking, the application of a machine learning algorithm will be one of four different categories:

1.  [Classification](https://en.wikipedia.org/wiki/Statistical_classification): generates a model that predicts discrete categories for new, unseen data.

2.  [Regression](https://en.wikipedia.org/wiki/Regression_analysis): generates a model that predicts continuous values for new, unseen data.

3.  [Dimensionality reduction](https://en.wikipedia.org/wiki/Dimensionality_reduction): identifies (and optionally ranks) the most important (potentially new) features (or dimensions) for a data set.

4.  [Clustering](https://en.wikipedia.org/wiki/Cluster_analysis): identifies clusters of instances in an N-dimensional feature space.

![](images/Machine%20learning%20cheatsheet.png){width="100%"}

One final point to clarify before proceeding with demonstrations of these different algorithm categories. When applying a machine learning algorithm to a problem, we often need to specify both model parameters and model hyperparameters. While they are similar, the difference between these two types of information depends on whether the value can be estimated from the data.

**Parameter**

:   A value that can be estimated from the data being analyzed and that is internal to the machine learning algorithm. A parameter is generally not specified by the programmer, and instead is determined automatically by the algorithm implementation (e.g., directly in the caret package). For example, the coefficients in a linear regression model are machine learning parameters.

**Hyperparameter**

:   A value that cannot be estimated from the data being analyzed and that is external to a specific machine learning algorithm. A hyperparameter is generally specified by the programmer prior to the start of the learning process. As a result, the hyperparameter directly influences the performance of the algorithm and thus is a tunable parameter. For example, the number of neighbors in a k-nearest neighbors implementation is a hyperparameter.

## Introducing Caret[^3]

[^3]: Content for this caret portion is borrowed from <https://www.rebeccabarter.com/blog/2017-11-17-caret_tutorial/>

Caret stands for **C**lassification **A**nd **Re**gression **T**raining. Apparently caret has little to do with our orange friend, the carrot. ü•ï

Not only does caret allow you to run a plethora of ML methods, it also provides tools for auxiliary techniques such as:

-   Data preparation (imputation, centering/scaling data, removing correlated predictors, reducing skewness)

-   Data splitting

-   Variable selection

-   Model evaluation

An extensive vignette for caret can be found here: <https://topepo.github.io/caret/index.html>

### **Data Pre-Processing** {#data-pre-processing}

Before we can apply a machine learning algorithm to the data of interest, we must divide the data into training and testing data sets. The *training* data are used to generate the supervised model, while the *testing* data are used to quantify the quality of the generated model. The function [`createDataPartition`](https://topepo.github.io/caret/data-splitting.html) can be used to create balanced splits of the data. If the `y` argument to this function is a factor, the random sampling occurs within each class and should preserve the overall class distribution of the data. For example, to create a single 60/40% split of the iris data:

```{r,echo=TRUE}
#lets split the data 60/40
library(caret)
trainIndex <- createDataPartition(iris$Species, p = .6, list = FALSE, times = 1)

#look at the first few
head(trainIndex)

#grab the data
irisTrain <- iris[ trainIndex,]
irisTest  <- iris[-trainIndex,]
```

### **Data Scaling**

Many machine learning <!--# NOT ALL OF THEM --> estimators are sensitive to variations in the spread of features within a data set. For example, if all features but one span similar ranges (e.g., zero through one) and one feature spans a much larger range (e.g., zero through one hundred), an algorithm might focus on the one feature with a larger spread, even if this produces a sub-optimal result. To prevent this, we generally scale the features to improve the performance of a given estimator.

Data scaling can take several forms:

-   **Standardization**: the data are scaled to have zero mean and unit (i.e., one) variance.

-   **Normalization**: the data are scaled to have unit mean and variance.

-   **Range**: the data are scaled to span a defined range, such as \[0,1\].

-   **Binarization**: the data are thresholded such that values below the threshold are zero (or False), and above the threshold are one (or True).

One important caveat to scaling is that any scaling technique should be *trained* via the `fit` method on the training data used for the machine learning algorithm. Once trained, the scaling technique can be applied equally to the training and testing data. In this manner, the testing data will always match the space spanned by the training data, which is what is used to generate the predictive model.

We demonstrate this approach in the following code cell, where we compute a standardization from our training data. This transformation is applied to both the training and testing data.

```{r,echo=TRUE}

preProcValues <- preProcess(irisTrain, method = c("center", "scale"))

trainTransformed <- predict(preProcValues, irisTrain)
testTransformed <- predict(preProcValues, irisTest)
```

I made a mistake here...Can you spot it üëÄ

```{r}
preProcValues <- preProcess(irisTest, method = c("center", "scale"))
testTransformed <- predict(preProcValues, irisTest)
```

```{r,echo=TRUE}

psych::describe(trainTransformed)
psych::describe(testTransformed)
```

With our data properly divided into training and testing samples, and the features appropriately scaled, we now change to the application of machine learning algorithms

### **Classification** {#classification}

The first type of algorithm we will demonstrate is classification, where we train an estimator to generate a model for the prediction of discrete labels. The following code cell completes this task by performing k-Nearest Neighbors classification. In this example, we use five nearest neighbors (but this value can be easily adjusted to see how the classification performance changes). As demonstrated in this code example, the standard classification process in caret is to first fit a model to the training data and to subsequently apply this model to predict values for the testing data. We can compute an accuracy measurement for our trained algorithm to compare the *predicted* and *known* labels for the testing data.

Since we set the k there is no reason to actually train... üòñ

```{r, echo=TRUE}

#fit knn
knn_fit<-train(Species~.,
               data=trainTransformed,
               method="knn",
               tuneGrid=data.frame(k=5))

knn_fit
```

```{r, echo=TRUE}
#predict on the test set
knn_pred<-predict(knn_fit,testTransformed)

#confusion
confusionMatrix(knn_pred,testTransformed$Species)

```

### **Regression** {#regression}

The second machine learning application we will demonstrate is regression. To demonstrate regression, we will introduce the [Decision Tree](https://en.wikipedia.org/wiki/Decision_tree_learning). A decision tree simply asks a set of questions of the data, and based on the answers, constructs a model representation. The tree (or model) is constructed by recursively splitting a data set into new groupings based on a statistical measure of the data along each different dimension (popular measures include the Gini coefficient or the entropy).

The terminal nodes in the tree are known as leaf nodes, and they provide the final predictions. In the simplest form, the leaf node simply provides the final prediction. More realistic decision trees generate a model prediction by using all instances in the leaf node, for example by averaging across them.

Before generating a regression model, however, we must pre-process our data to identify our independent variables (or features) and our dependent variable (or feature). Given a set of new independent variables, a regression model will predict the dependent variable. In the following code cell, we first select the first three features to be our independent variables and the fourth variable to be our dependent variable. We divide these into training and testing samples.

```{r, echo=TRUE}


#fit Decision Tree
DT_fit1<-train(Petal.Width~Sepal.Length+Sepal.Width+Petal.Length,
               data=trainTransformed,
               method="rpart")

DT_fit1




```

Install another package

```{r,echo=TRUE,eval=FALSE}

install.packages("rpart.plot")
```

We can plot simple trees

```{r, echo=TRUE}

rpart.plot::prp(DT_fit1$finalModel,box.palette = "Reds", tweak = 1.2)
```

Lets predict

```{r, echo=TRUE}

#predict on the test set
DTfit1_pred<-predict(DT_fit1,testTransformed)

```

### Rsquared üòà

```{r, echo=TRUE}

preds<-DTfit1_pred
actual<-testTransformed$Petal.Width
#one formulation
rss <- sum((preds - actual) ^ 2)  ## residual sum of squares
tss <- sum((actual - mean(actual)) ^ 2)  ## total sum of squares
rsq <- 1 - rss/tss
rsq

#another
regss <- sum((preds - mean(preds)) ^ 2) ## regression sum of squares
regss / tss

#another
cor(preds,actual)^2


```

<details>

<summary>

#### Time to blow RSquared up[^4] üí•

[^4]: <https://data.library.virginia.edu/is-r-squared-useless/>

</summary>

<p>

[R-squared](https://en.wikipedia.org/wiki/Coefficient_of_determination) is a statistic that often accompanies regression output. It ranges in value from 0 to 1 and is usually interpreted as summarizing the percent of variation in the response that the regression model explains. So an R-squared of 0.65 might mean that the model explains about 65% of the variation in our dependent variable. Given this logic, we prefer our regression models have a high R-squared.

In R, we typically get R-squared by calling the summary function on a model object. Here's a quick example using simulated data:

```{r,echo=TRUE}

# independent variable
x <- 1:20 
# for reproducibility
set.seed(1) 
# dependent variable; function of x with random error
y <- 2 + 0.5*x + rnorm(20,0,3) 
# simple linear regression
mod <- lm(y~x)
# request just the r-squared value
summary(mod)$r.squared          


```

One way to express R-squared is as the sum of squared fitted-value deviations divided by the sum of squared original-value deviations:

$$
R^{2} =  \frac{\sum (\hat{y} ‚Äì \bar{\hat{y}})^{2}}{\sum (y ‚Äì \bar{y})^{2}}
$$

We can calculate it directly using our model object like so:

```{r, echo=TRUE}
# extract fitted (or predicted) values from model
f <- mod$fitted.values
# sum of squared fitted-value deviations
mss <- sum((f - mean(f))^2)
# sum of squared original-value deviations
tss <- sum((y - mean(y))^2)
# r-squared
mss/tss                      

```

1\. *R-squared does not measure goodness of fit. It can be arbitrarily low when the model is completely correct.* By making$œÉ^2$ large, we drive R-squared towards 0, even when every assumption of the simple linear regression model is correct in every particular.

What is $œÉ^2$? When we perform linear regression, we assume our model almost predicts our dependent variable. The difference between "almost" and "exact" is assumed to be a draw from a Normal distribution with mean 0 and some variance we call $œÉ^2$.

This statement is easy enough to demonstrate. The way we do it here is to create a function that (1) generates data meeting the assumptions of simple linear regression (independent observations, normally distributed errors with constant variance), (2) fits a simple linear model to the data, and (3) reports the R-squared. Notice the only parameter for sake of simplicity is `sigma`. We then "apply" this function to a series of increasing $œÉ$ values and plot the results.

```{r, echo=TRUE}



r2.0 <- function(sig){
  # our predictor
  x <- seq(1,10,length.out = 100)   
  # our response; a function of x plus some random noise
  y <- 2 + 1.2*x + rnorm(100,0,sd = sig) 
  # print the R-squared value
  summary(lm(y ~ x))$r.squared          
}

sigmas <- seq(0.5,20,length.out = 20)
 # apply our function to a series of sigma values
rout <- sapply(sigmas, r2.0)            
plot(rout ~ sigmas, type="b")
```

R-squared tanks hard with increasing sigma, even though the model is *completely correct* in every respect.

2.  *R-squared can be arbitrarily close to 1 when the model is totally wrong.*

The point being made is that R-squared does not measure goodness of fit.

```{r, echo=TRUE}

set.seed(1)
# our predictor is data from an exponential distribution
x <- rexp(50,rate=0.005)
# non-linear data generation
y <- (x-1)^2 * runif(50, min=0.8, max=1.2) 
# clearly non-linear
plot(x,y)				     
```

```{r,echo=TRUE}
summary(lm(y ~ x))$r.squared
```

It's very high at about 0.85, but the model is completely wrong. Using R-squared to justify the "goodness" of our model in this instance would be a mistake. Hopefully one would plot the data first and recognize that a simple linear regression in this case would be inappropriate.

3\. *R-squared says nothing about prediction error, even with* $œÉ^2$ exactly the same, and no change in the coefficients. R-squared can be anywhere between 0 and 1 just by changing the range of X. We're better off using Mean Square Error (MSE) as a measure of prediction error.

MSE is basically the fitted y values minus the observed y values, squared, then summed, and then divided by the number of observations.

Let's demonstrate this statement by first generating data that meets all simple linear regression assumptions and then regressing y on x to assess both R-squared and MSE.

```{r,echo=TRUE}
x <- seq(1,10,length.out = 100)
set.seed(1)
y <- 2 + 1.2*x + rnorm(100,0,sd = 0.9)
mod1 <- lm(y ~ x)
summary(mod1)$r.squared
# Mean squared error
sum((fitted(mod1) - y)^2)/100
```

Now repeat the above code, but this time with a different range of x. Leave everything else the same:

```{r,echo=TRUE}
 # new range of x
x <- seq(1,2,length.out = 100)      
set.seed(1)
y <- 2 + 1.2*x + rnorm(100,0,sd = 0.9)
mod1 <- lm(y ~ x)
summary(mod1)$r.squared
# Mean squared error
sum((fitted(mod1) - y)^2)/100        

```

The R-squared falls from 0.94 to 0.15 but the MSE remains the same. In other words the predictive ability is the same for both data sets, but the R-squared would lead you to believe the first example somehow had a model with more predictive power.

4.  *R-squared can easily go down when the model assumptions are better fulfilled.*

Let's examine this by generating data that would benefit from transformation. Notice the R code below is very much like our previous efforts but now we exponentiate our y variable.

```{r,echo=TRUE}

x <- seq(1,2,length.out = 100)
set.seed(1)
y <- exp(-2 - 0.09*x + rnorm(100,0,sd = 2.5))
summary(lm(y ~ x))$r.squared

plot(lm(y ~ x), which=3)
```

R-squared is very low and our residuals vs. fitted plot reveals outliers and non-constant variance. A common fix for this is to log transform the data. Let's try that and see what happens:

```{r,echo=TRUE}
plot(lm(log(y)~x),which = 3) 
```

The diagnostic plot looks much better. Our assumption of constant variance appears to be met. But look at the R-squared:

```{r,echo=TRUE}

summary(lm(log(y)~x))$r.squared 
```

It's even lower! This is an extreme case and it doesn't always happen like this. In fact, a log transformation will usually produce an increase in R-squared. But as just demonstrated, assumptions that are better fulfilled don't always lead to higher R-squared.

5.  *It is very common to say that R-squared is "the fraction of variance explained" by the regression. \[Yet\] if we regressed X on Y, we'd get exactly the same R-squared. This in itself should be enough to show that a high R-squared says nothing about explaining one variable by another.*

This is the easiest statement to demonstrate:

```{r,echo=TRUE}

x <- seq(1,10,length.out = 100)
y <- 2 + 1.2*x + rnorm(100,0,sd = 2)
summary(lm(y ~ x))$r.squared

summary(lm(x ~ y))$r.squared

```

Does x explain y, or does y explain x? Are we saying "explain" to dance around the word "cause"? In a simple scenario with two variables such as this, R-squared is simply the square of the correlation between x and y:

```{r,echo=TRUE}

all.equal(cor(x,y)^2, summary(lm(x ~ y))$r.squared, summary(lm(y ~ x))$r.squared)
```

Let's recap:

-   R-squared does not measure goodness of fit.

-   R-squared does not measure predictive error.

-   R-squared does not necessarily increase when assumptions are better satisfied.

-   R-squared does not measure how one variable explains another.

</p>

</details>

### **Dimensionality Reduction** {#dimensionality-reduction}

When confronted with a large, multi-dimensional data set, one approach to simplify any subsequent analysis is to reduce the number of dimensions (or features) that must be processed. In some cases, features can be removed from an analysis based on business logic, or the features that contain the most information can be quantified somehow. More generally, however, we can employ [dimensional reduction](https://en.wikipedia.org/wiki/Dimensionality_reduction), a machine learning technique that quantifies relationships between the original dimensions (or features, attributes, or columns of a DataFrame) to identify new dimensions that better capture the inherent relationships within the data.

The standard technique to perform this is known as [principal component analysis](https://en.wikipedia.org/wiki/Principal_component_analysis), or PCA. Mathematically, we can derive PCA by using linear algebra to solve a set of linear equations. This process effectively rotates the data into a new set of dimensions, and by ranking the importance of the new dimensions, we can optimally select fewer dimensions for use in other machine learning algorithms.

The *PCA* estimator requires one tunable hyper-parameter that specifies the target number of dimensions. This value can be arbitrarily selected, perhaps based on prior information, or it can be iteratively determined. After the model is created, we fit the model to the data and next create our new, rotated data set. This is demonstrated in the next code cell.

```{r,echo=TRUE}

library(caret)
#store our data in another object
dat <- iris
#take the 4 continuous variables and perform PCA
caret.pca <- preProcess(dat[,-5], method="pca",pcaComp=2)

caret.pca

caret.pca$
#use that data to form our new inputs
dat2 <- predict(caret.pca, dat[,-5])


#using stats
stat.pca <- prcomp(dat[,-5],
                 center = TRUE,
                 scale. = TRUE) 

# plot method
plot(stat.pca, type = "l")

summary(stat.pca)
```

Below is a graphical representation[^5]

[^5]: <https://www.r-bloggers.com/2013/11/computing-and-visualizing-pca-in-r/>

```{r,echo=FALSE,eval=FALSE}
library(devtools)
install_github("vqv/ggbiplot")
```

```{r,echo=FALSE}

library(ggbiplot)
g <- ggbiplot(stat.pca, obs.scale = 1, var.scale = 1, 
              groups = dat$Species, ellipse = TRUE, 
              circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal', 
               legend.position = 'top')
print(g)

```

At the end of the previous code cell, we measure the amount of the original variance (or spread) in the original data that is captured by each new dimension. As this example shows, these two new dimensions capture almost 96% of the variance in the original data. This means that any analysis that uses only these two new dimensions will closely represent the analysis if performed on the entire data.

### 

```{r detach1,echo=FALSE}
#need to detach some ggbiplot and plyr becuase it 
#causes problems later
detach(package:ggbiplot)
detach(package:plyr)

```

### **Clustering** {#clustering}

The last machine learning technique we will explore in this notebook is [cluster finding](https://en.wikipedia.org/wiki/Cluster_analysis). In this introductory notebook, we will demonstrate one of the simplest clustering techniques, spatial clustering, which seeks to first find NN clusters in a data set and to subsequently identify to which cluster each instance (or data point) belongs. The specific algorithm we employ below is the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering), which is one of the simplest to understand. In this algorithm, we start with a guess for the number of clusters (again this can be based on prior information or iteratively quantified). We randomly place cluster centers in the data and determine how well the data *cluster* to these cluster centers. This information is used to pick new cluster centers, and the process continues until a solution converges (or we reach a predefined number of iterations).

```{r,echo=TRUE}

Clusters<-kmeans(trainTransformed[,-5],centers=3)

Clusters

```

The above list is an output of the `kmeans()` function. Let's see some of the important ones closely:

-   `cluster`: a vector of integers (from 1:k) indicating the cluster to which each point is allocated.

-   `centers`: a matrix of cluster centers.

-   `withinss`: vector of within-cluster sum of squares, one component per cluster.

-   `tot.withinss`: total within-cluster sum of squares. That is, `sum(withinss)`.

-   `size`: the number of points in each cluster.

```{r}
library(tidyverse)

Clusterdata<-trainTransformed
Clusterdata$Cluster<-as.factor(Clusters$cluster)

#view the whole dataset
knitr::kable(Clusterdata)%>%
  kableExtra::kable_styling("striped")%>%
  kableExtra::scroll_box(width = "100%",height="300px")
```

```{r}

#Remember me
ggplot(data=Clusterdata,mapping = aes(x=Sepal.Width,y=Petal.Width,color=Cluster))+geom_point(alpha=0.5)

ggplot(data=Clusterdata,mapping = aes(x=Sepal.Width,y=Petal.Width,color=Cluster))+geom_point(alpha=0.5)+facet_wrap(~Species)

ggplot(data=Clusterdata,mapping = aes(x=Sepal.Width,y=Petal.Width,color=Species))+geom_point(alpha=0.5) + 
   geom_point(data=as.data.frame(Clusters$centers), aes(color="Cluster center"), size=5) + theme(legend.title = element_blank())+ggtitle("Iris Cluster Demonstration")
```

## Exercise 1

Using the code above, answer the following questions.

1.  Change the p=.6 to p=.75 in the [Data Pre-Processing](#data-pre-processing) section. How did the [classification](#classification) results change?

    Where do I start? Well I know that I need to split the data differently. The question asks me to split the data where 75% of the full dataset is split into Training data and that would leave 25% left for Testing data. Why do we have Training data and Testing data? Running and evaluating the model on the training data is like

    ```{r 1.1.1_setup,echo=TRUE,warning=FALSE,message=FALSE}


    library(caret)
    trainIndex <- createDataPartition(iris$Species, p = .6, list = FALSE, times = 1)



    ```

2.  Change the p=.6 to p=.4 in the [Data Pre-Processing](#data-pre-processing) section. How did the [classification](#classification) results change?

3.  Change the `k` hyper-parameter in the k-nn estimator to three (and ten). In other words change the 5 to 10 in `tuneGrid=data.frame(k=5)` in the [Classification](#classification) section. How did the [classification](#classification) results change?

4.  Change the p=.6 to p=.75 in the [Data Pre-Processing](#data-pre-processing) section. How did the [regression](#regression) results change?

5.  Change the `pcaComp` hyper-parameter in the PCA code example to three (and four) in the [Dimensionality Reduction](#dimensionality-reduction) section. What are the new explained variances?

6.  Change the `centers` hyper-parameter in the cluster finding code example to two (and four) in the [Clustering](#clustering) section. Where are the new cluster centers? Does this look better or worse?

7.  What does the [set.seed](https://r-coder.com/set-seed-r/) function in R do? Why use it? Should we have used it above?

## **Model Persistence** {#model-persistence}

As the previous code cells demonstrate, we can generate machine learning models rather easily for small data sets by using the caret library. For larger data sets, however, either in the number of instances, the number of features, or both, building a quality machine learning model can take considerable time and effort. As a result, we may wish to persist a trained machine learning model so that it can be applied to new data at a later time.

```{r}

#save our model
save(DT_fit1,file = "DT_fit1.Rda")

#remove it from  the environment
rm(DT_fit1)
```

```{r}
#load our model
load(file = "DT_fit1.Rda")
```

Whenever you load it back you can use it just like before.

```{r, include=FALSE}
library(xaringan)
library(xaringanExtra)

xaringanExtra::use_panelset()
xaringanExtra::style_panelset_tabs(font_family = "inherit")

```

## Deep Dive

::: panelset
::: panel
[Regression]{.panel-name}

Regression is awesome
:::

::: panel
[K-NN]{.panel-name}

K-NN is simple, but awesome
:::
:::

# Regression {#regression2}

## **Introduction to Linear Regression**

This lesson builds on the ordinary linear regression concept, introduced in business statistics, to discuss linear regression as a machine learning task. Regression, or the creation of a predictive model from data, is one of the key machine learning tasks. By using linear regression, which can often be solved analytically, we will introduce the concept of minimizing a cost function to determine the optimal model parameters in a straight-forward manner.

### **Objectives**

By the end of this lesson, you will be able to

-   explain the role of the loss function in machine learning,
-   articulate how to compute a regression on multiple variables,
-   explain the different statistical measures that quantify the quality of a regression,
-   utilize categorical variables in a machine learning model, and
-   compute a linear regression model

You were introduced to the concept of linear regression by learning about simple linear regression. This initial approach treated linear regression as a statistical technique where the relation between independent variables (or features) and a dependent variable (or target) was determined by a mathematical relation. While powerful, the previous approach treated linear regression as a distinct, statistical approach to relating independent variables with a dependent variable. In this lesson, we instead treat linear regression as a machine learning task. As a result, we will use regression to *fit a model to data*. The model generated in this fashion can be explored in greater detail to either understand why the provided data follow the generated model (i.e., gain insight into the data), or the model can be used to generate new dependent values from future or unseen data (i.e., make predictions from the model).

We will use the *tips* data set. After loading this data, we display several rows, and next compute a simple linear regression to predict the `tip` feature from the `total_bill` feature.

For this section we need to load libraries:

```{r setup1, echo=TRUE}
library(tidyverse)
library(caret)

```

```{r load data, echo=TRUE}

#load data. 
#curl package lets us download data from a website with the proper location
#check the packages tab and see if you have curl
#try following
  #?curl

library(curl)

load(curl("https://raw.githubusercontent.com/Professor-Hunt/ACC8143/main/data/tips.rda"))

```

```{r look, echo=TRUE}

head(tips,5)

#view the whole dataset
knitr::kable(tips)%>%
  kableExtra::kable_styling("striped")%>%
  kableExtra::scroll_box(width = "100%",height="300px")
```

Perform simple linear regression

```{r OLS1, echo=TRUE}

OLS1<-lm(formula=tip~total_bill,data=tips)
#general output
OLS1
#more common output
summary(OLS1)
#correlation or R-squared...
cor(tips$total_bill,tips$tip)^2
```

### **Formalism**

Formally, this simple linear model related the independent variables $x_i$ to the dependent variables $y_i$ in our data set via two parameters: an intercept, and a slope. Mathematically, we express this relation in the following form:

$$
f(x_i) = \beta * x_i + \alpha + \epsilon_i
$$

where $\epsilon_i$ accounts for the difference between the model and the data for each data point $(x_i,y_i)$. If we have a perfect model, these errors, $\epsilon_i$, are all zero, and $y_i = f(x_i)$. In real life, however, the error terms rarely vanish because even if the original relationship is perfect noise creeps into the measurement process.

As a result, in this simple example we wish to determine the model parameters: $\beta_i$, and $\alpha_i$ that minimize the values of $\epsilon_i$. We could perform this process in an iterative manner, trying different values for the model parameters and measuring the error function. This approach is often used in machine learning, where we define a **cost function** that we seek to minimize by selecting the best model parameters.

In the case of a simple linear model, we have several potential cost (or loss) functions that we could seek to minimize, but we will use the common *l2-norm*: $\epsilon_i^2 = \left( \ y_i - f(x_i) \ \right)^2$, where $f(x_i)$ is defined by our model parameters. We demonstrate this approach visually in the following code block, where we minimize the sum of the *l2-norm* model residuals, which is done by finding the best model parameters: $\hat{\beta}$, and $\hat{\alpha}$.

<details>

<summary>

***Formulas*** üò¢

</summary>

<p>

![](images/beta%20formula.png){width="100%"}

</p>

</details>

```{r Anscombe, echo=TRUE}

#Get some data
AnsDat<-anscombe%>%
  select(y1,x1)

#extract x and y columns
Y<-AnsDat$y1
X<-AnsDat$x1

#find the number of data points
n<-nrow(AnsDat)

#determine mean values
mean_x<-mean(X,na.rm = TRUE)
mean_y<-mean(Y,na.rm = TRUE)

#determine best fit model parameters (from simple linear regression)
beta = sum((X - mean_x) * (Y - mean_y)) / sum((X - mean_x)**2)
beta

alpha = mean_y - beta * mean_x
alpha

#lets double check
summary(lm(formula=Y~X,data=AnsDat))
```

Plots

```{r plots1,echo=TRUE}

library(ggplot2)

#create regression plot
ggplot(AnsDat,aes(x1, y1)) +
  geom_point() +
  geom_smooth(method='lm', se=FALSE) +
  geom_segment(aes(x=X, xend=X, y=Y, yend=lm(Y~X)$fitted.values, color="error"))+
  theme_minimal() +
  labs(x='X Values', y='Y Values', title='Linear Regression Plot') +
  theme(plot.title = element_text(hjust=0.5, size=20, face='bold')) + 
  theme(legend.title = element_blank())


```

### **Cost Function**

This simple example demonstrates a fundamental concept in machine learning, namely the minimization of a cost (or loss) function, which quantifies how well a model represents a data set. For a given data set, the cost function is completely specified by the model parameters, thus a more complex model has a more complex cost function, which can become difficult to minimize. To clarify this point, we now turn to the exploration of the shape of cost functions.

For simplicity, we start with a one-dimensional cost function, a linear model with no intercept: $f(x_i) = \beta x_i$. In the following code cell, we compute the cost function for a given data set as a function of the unknown parameter $\beta$. In this case, the minimum is easy to visualize, given the steepness of the cost function around the minimum.

```{r cost function, echo=TRUE}

#define our betas
betas<-seq(-4,4,length.out=100)

#define our cost function
l2n = sapply(as.matrix(betas), function(m) log(sqrt(sum((as.matrix(tips$tip) - m*as.matrix(tips$total_bill))^2))))  # The L2-norm

```

```{r cost plot, echo=TRUE}

library(ggplot2)
costplot<-as.data.frame(cbind(betas,l2n))
#create regression plot
ggplot(costplot,aes(betas, l2n)) +
  geom_point(color="blue") + geom_line()+
  geom_vline(xintercept=0, color="red")
```

In general, however, we face two challenges:

1.  the cost function will likely be more complex, and

2.  our data will be higher dimensional.

In general, we must employ a (potentially) complex mathematical technique to find the (hopefully) global minimum of the cost function. We can increase the complexity of our *cost* function analysis by extending the original model to include both a slope and an intercept. We now must find the minimum of this two dimensional model, given our observed data. We do this in the following code cell where we generate a grid of values in our two parameters, and compute the cost function for these different parameter combinations.

To display the data which generates a sampling grid across potential values for the slope $\beta$ and intercept $\alpha$ in our model. We once again *vectorize* our cost function and broadcast it across the sampling grid. We accumulate the cost at each grid point and generate a two-dimensional image of the values of the cost function across our sampling grid. To make the image appear cleaner, we perform *Gaussian* interpolation between sample points.

As the following two-dimensional image displays, our cost function is not aligned with either parameter, but is steeper in the slope parameter and less steep in the intercept parameter. Thus, we would expect that small changes in the slope will quickly increase our cost (which we saw in the previous one-dimensional example), while small changes in the intercept will produce smaller changes in our cost function (note that the range for intercepts is much larger than the range for the slope parameters).

```{r cost2,echo=TRUE}

#define our betas
betas<-seq(-4,4,length.out=100)
alphas<-seq(-40,40,length.out=100)
## Generate a grid of X- and Y- values on which to predict
grid <-expand.grid(betas,alphas)
#define our cost function
l2n2 = mapply( function(m,b) log(sqrt(sum((as.matrix(tips$tip) - m*as.matrix(tips$total_bill) - b)^2))),as.matrix(grid$Var1),as.matrix(grid$Var2))  # The L2-norm

```

```{r cost2 plot, echo=TRUE}

library(ggplot2)

ggplot(grid, aes(Var1, Var2)) +
  geom_raster(aes(fill=l2n2),show.legend = FALSE) +
  geom_point(color="deepskyblue3",aes(OLS1$coefficients[[2]],OLS1$coefficients[[1]]))+
  theme_minimal() +
  labs(x=expression(beta), y=expression(alpha), title=expression(paste("Cost function for"," ",y==beta*x+alpha))) +
  theme(plot.title = element_text(hjust=0.5, size=20, face='bold')) + 
  theme(legend.title = element_blank())

```

As we move to higher dimensional data sets or more complex cost functions, the challenge of finding the global minimum becomes increasingly difficult. As a result, many mathematical techniques have been developed to find the global minimum of a (potentially) complex function. The standard approach is [gradient descent](https://en.wikipedia.org/wiki/Gradient_descent), where we use the fact that the first derivative (or gradient) measures the slope of a function at a given point. We can use the slope to infer which direction is *downhill* and thus travel (hopefully) towards the minimum.

A major challenge with this approach is the potential to become stuck in a local and not global minima. Thus, modifications are often added to reduce the likelihood of becoming stuck in a local minimum. One popular example of this approach is known as [stochastic gradient descent](https://en.wikipedia.org/wiki/Stochastic_gradient_descent). This algorithm employs standard gradient descent, but adds an occasional random jump in the parameter space to reduce the chances of being stuck in a local *valley*. Another, very different, approach to this problem is the use of [genetic algorithms](https://en.wikipedia.org/wiki/Genetic_algorithm), which employ techniques from evolutionary biology to minimize the cost function.

For a mental picture of this process, imagine hiking in the mountains and flip the challenge to finding the highest peak, so we will use gradient ascent. Gradient ascent is similar to finding the local mountain peak and climbing it. This local peak might look like it is the largest, but a random jump away from the local peak might enable one to view much larger peaks beyond, which can subsequently be climbed with a new gradient ascent.

Whenever you perform machine learning in the future, you should keep in mind that the model that you generate for a given data set has generally resulted from the minimization of a cost function. Thus, there remains the possibility that with more effort, more data, or a better cost minimization strategy, a new, and better model may potentially exist.

```{r rmse, echo=FALSE}

#what is a function?
rmse = function(actual, predicted) {
  sqrt(mean((actual - predicted) ^ 2))
}

```

```{r samples, echo=TRUE}
#set the seed :)
set.seed(1)
#get our samples

#lets split the data 60/40
library(caret)
trainIndex <- createDataPartition(tips$tip, p = .6, list = FALSE, times = 1)

#look at the first few
#head(trainIndex)

#grab the data
tipsTrain <- tips[ trainIndex,]
tipsTest  <- tips[-trainIndex,]
```

## **Linear Regression**

In the following code cells, we use the `lm` estimator to fit our sample data, plot the results, and finally display the fit coefficients.

The first code cell defines a function that will make two plots. The top plot is a comparison between a single independent variable (Total Bill) and the dependent variable (Tip). This plot differentiates the training data, the testing data, and the linear model. The bottom plot displays the model residuals (dependent variable - model result) as a function of the independent variable. The primary benefit of this plot is the ability to identify any structure in the residuals, which can indicate a bad model. For example, if the residual plot shows a linear relationship, that indicates the original model incorrectly related the independent and dependent variables.

In the following code cells, we first compute a linear fit with no intercept, after which we compute a linear fit with both a slope and an intercept. The fit results are displayed as well as the regression and residual plots.

The code below computes a regression with no intercept.

```{r model noint, echo=TRUE}

#fit simple linear regression model
model_noint <- lm(tip ~ 0+total_bill , data = tipsTrain)

noint_results<-predict(model_noint,tipsTest)
###compute fit
summary(model_noint)

knitr::kable(caret::RMSE(noint_results,tipsTest$tip),col.names = "RMSE")


```

Below is the regression plot for the model with no intercept.

```{r regplot1, echo=TRUE}

tipsTest$Sample<-"Testing"
tipsTrain$Sample<-"Training"

Combined_Tips<-rbind(tipsTest,tipsTrain)
#create regression plot with customized style
ggplot(Combined_Tips,aes(x=total_bill, y=tip,color=Sample)) +
  geom_point(alpha=.5) +
  theme_minimal() +
  labs(x='X Values', y='Y Values', title='Linear Regression Plot') +
  theme(plot.title = element_text(hjust=0.5, size=20, face='bold')) +
  geom_abline(aes(slope=model_noint$coefficients[[1]],intercept=0),color="red")
```

Below is a residual (error) plot.

```{r residplot1, echo=TRUE}
library(tidyverse)
#create residuals
testwithpred<-as.data.frame(cbind(noint_results,tipsTest))
#create residuals
testwithpred<-testwithpred%>%
  rename(prediction=noint_results)%>%
  mutate(error=tip-prediction)

#create regression plot with customized style
ggplot(testwithpred,aes(x=total_bill, y=error)) +
  geom_point(alpha=.5,color="deepskyblue") +
  theme_minimal() +
  labs(x='Total Bill', y='Error', title='Regression Error Plot') +
  theme(plot.title = element_text(hjust=0.25, size=20, face='bold')) +
  geom_hline(yintercept=0,color="red",linetype="dashed")

```

[Link to some good examples of interpreting residual plots üè´](https://www.qualtrics.com/support/stats-iq/analyses/regression-guides/interpreting-residual-plots-improve-regression/)

Model with an intercept

```{r model int,echo=TRUE}

#fit simple linear regression model
model_int <- lm(tip ~ total_bill , data = tipsTrain)

int_results<-predict(model_int,tipsTest)
###compute fit
summary(model_int)

knitr::kable(caret::RMSE(int_results,tipsTest$tip),col.names = "RMSE")

```

Below is a model with an intercept

```{r regplot2, echo=TRUE}

#create regression plot with customized style
ggplot(Combined_Tips,aes(x=total_bill, y=tip,color=Sample)) +
  geom_point(alpha=.5) +
  theme_minimal() +
  labs(x='X Values', y='Y Values', title='Linear Regression Plot') +
  theme(plot.title = element_text(hjust=0.5, size=20, face='bold')) +
  geom_abline(aes(slope=model_int$coefficients[[2]],intercept=model_int$coefficients[[1]]),color="red")
```

Residual Plot

```{r residplot2, echo=TRUE}
#create residuals
testwithpred2<-as.data.frame(cbind(int_results,tipsTest))
#create residuals
testwithpred2<-testwithpred2%>%
  rename(prediction=int_results)%>%
  mutate(error=tip-prediction)

#create regression plot with customized style
ggplot(testwithpred2,aes(x=total_bill, y=error)) +
  geom_point(alpha=.5,color="deepskyblue") +
  theme_minimal() +
  labs(x='Total Bill', y='Error', title='Regression Error Plot') +
  theme(plot.title = element_text(hjust=0.25, size=20, face='bold')) +
  geom_hline(yintercept=0,color="red",linetype="dashed")
```

## **Multivariate Regression**

Often, using more data will result in more accurate models, since finer details can be captured. For example, if we see structure in a residual plot, the easiest solution is often to add additional independent variables to our model, which results in a multivariate linear regression model. The only major change required to our previous model building code is the expansion of our equation in the `lm()` function to include the additional independent variables.

To demonstrate building a multi-variate regression model, the following code uses both the `total_bill` and `size` features from the *tips* data set to use as independent variables. The `tip` feature is used as the dependent variable.

The following code generates a multi-variate linear model, displays the model parameters, and displays the regression and residual plots. To make the regression plot, we must use only one feature (in this case the `total_bill`). As a result, when we display the generated model, we get a series of lines that are the projections of the multi-variate model on this two-dimensional figure.

```{r multireg1,echo=TRUE}

#fit simple linear regression model
model_multi <- lm(tip ~ total_bill+size , data = tipsTrain)

multi_results<-predict(model_multi,tipsTest)
###compute fit
summary(model_multi)

knitr::kable(caret::RMSE(multi_results,tipsTest$tip),col.names = "RMSE")
```

```{r regplot3, echo=TRUE}


library(plotly)

scatter.plot<-plot_ly(Combined_Tips, x = ~total_bill, y = ~size, z = ~tip, color = ~Sample, colors = c('lightblue', 'violet'))%>% 
  add_markers(size=6)%>% 
  layout(scene = list(
          xaxis = list(title = 'Total Bill'),
          yaxis = list(title = 'Size'),
          zaxis = list(title = 'Tip')))

#scatter.plot

library(reshape2)
#Graph Resolution (more important for more complex shapes)
graph_reso <- 0.05

#Setup Axis
axis_x <- seq(min(tipsTest$total_bill), max(tipsTest$total_bill), by = graph_reso)
axis_y <- seq(min(tipsTest$size), max(tipsTest$size), by = graph_reso)

#Sample points
lm_surface <- expand.grid(total_bill = axis_x,size = axis_y,KEEP.OUT.ATTRS = F)
lm_surface$tips <- predict(model_multi, newdata = lm_surface)
lm_surface <- acast(lm_surface, size ~ total_bill, value.var = "tips")

scatter.plot<- add_trace(p = scatter.plot,
                       z = lm_surface,
                       x = axis_x,
                       y = axis_y,
                       type = "surface",colorscale = list(c(0, 1), c("wheat", "royalblue")))%>%
                layout(legend = list(x = -.1, y = 1), title="Regression Plot")

scatter.plot
```

```{r resid3d, echo=TRUE}

#create residuals
testwithpred3<-as.data.frame(cbind(multi_results,tipsTest))
#create residuals
testwithpred3<-testwithpred3%>%
  rename(prediction=multi_results)%>%
  mutate(error=tip-prediction)


library(plotly)

scatter.plot<-plot_ly(testwithpred3, x = ~total_bill, y = ~size, z = ~error)%>% 
  add_markers(size=6)%>% 
  layout(scene = list(
          xaxis = list(title = 'Total Bill'),
          yaxis = list(title = 'Size'),
          zaxis = list(title = 'Error')))

#scatter.plot

library(reshape2)
#Graph Resolution (more important for more complex shapes)
graph_reso <- 0.05

#Setup Axis
axis_x <- seq(min(tipsTest$total_bill), max(tipsTest$total_bill), by = graph_reso)
axis_y <- seq(min(tipsTest$size), max(tipsTest$size), by = graph_reso)

#Sample points
lm_surface <- expand.grid(total_bill = axis_x,size = axis_y,KEEP.OUT.ATTRS = F)
lm_surface$error <-rep(0,nrow(lm_surface))
lm_surface <- acast(lm_surface, size ~ total_bill, value.var = "error")

scatter.plot<- add_trace(p = scatter.plot,
                       z = lm_surface,
                       x = axis_x,
                       y = axis_y,
                       type = "surface",
                       colorscale = list(c(0,1), c("red","red")))%>%
                       layout(showlegend=FALSE, title= "Error Plot")

hide_colorbar(scatter.plot)
```

## Exercise 2

1.  Run a simple regression to predict `total_bill` with `tip`. What is the RSquared? What is the RMSE?
2.  Plot the regression and the residuals from number 1.
3.  Run a multivariate regression to predict `total_bill` with `tip` and `size`. What is the RSquared? What is the RMSE?
4.  Try to make a 3D plot...but do not spend more than 10-15 minutes on this one.

### **Categorical Variables**

Many data sets contain features that are non-numerical. For example, the *tips* data set contains a `day` feature that can take one of four values: `Thur`, `Fri`, `Sat`, and `Sun`. This data set also contains a `sex` feature that can be `Female` or `Male`, and a `smoker` feature that can be `No` or `Yes`. Each of these features are [categorical features](https://en.wikipedia.org/wiki/Categorical_variable), in that they can only take on one of a limited number of possible values. In general, the possible states are fixed, such as the `sex`, `smoker`, and `day` features discussed previously.

Categorical features can take several forms. For example, a categorical feature, such as `sex` or `smoker` that can take on one of two values is known as a binary feature. Furthermore, categorical features can also be categorized into nominal and ordinal features (note that other classes are also possible, but beyond the scope of this class).

A [nominal feature](https://en.wikipedia.org/wiki/Nominal_category) either is in a category or it isn't, and there are no relations between the different categories. For example, the `sex` category is nominal since there is no numerical relation or ordering among the possible values. On the other hand, an [ordinal feature](https://en.wikipedia.org/wiki/Ordinal_data) is a categorical feature where the possible values have an intrinsic relationship. For example, if we encode the results of a race as *first*, *second*, and *third*, these values have a relationship, in that *first* comes before the other two, and the difference between *first* and *second* is the same as between *second* and *third*. In our *tips* example, we could treat the `day` features in this manner, since the days often are treated as having an ordinal relationship.

```{r dummies, echo=TRUE}

df = data.frame(Color = c("Red", "Blue", "Green", "Blue", "Blue", "Red"))

knitr::kable(df)

```

This encoding is fine if the data are ordinal, but in this case, our colors are likely nominal and there is no numerical relationship between the different features. Thus, we need to perform an additional transformation to convert our data into a numerical format that a machine learning model can effectively process. To do this, a commonly used approach known as *One Hot Encoding* is used. This approach generates a new feature for each possible value in our category. Thus, for our four colors, we need four features. These features will be binary, in that a value of zero indicates that the feature is not present for the specific instance, and a value of one indicates it is present. Furthermore, only one set of these new features can be present (or on) for a specific instance.

```{r dummy2, echo=TRUE}

library(varhandle)
dumvars<-as.data.frame(to.dummy(df$Color,"dum"))

knitr::kable(dumvars)
```

## **Linear Regression with Categorical Variables**

We fit the model, display the fit coefficients, compute the model performance, and finally display the regression model plot and the residual model plot. In this case, our new model performs slightly worse than the original single variable linear regression model. This suggests that the day of the week is not an important variable in the underlying relationship between `total_bill` and `tip`. By evaluating other feature combinations, you may be able to find a better predicting model.

```{r dumreg, echo=TRUE}

dumvars_Train<-as.data.frame(to.dummy(tipsTrain$day,"dum"))

dumvars_Train<-cbind(dumvars_Train,tipsTrain)

#fit simple linear regression model

model_dum1 <- lm(tip ~total_bill+ dum.Sat+dum.Sun+dum.Thur+dum.Fri , data = dumvars_Train)

dumvars_Test<-as.data.frame(to.dummy(tipsTest$day,"dum"))

dumvars_Test<-cbind(dumvars_Test,tipsTest)

dum1_results<-predict(model_dum1,dumvars_Test)
###compute fit
summary(model_dum1)

knitr::kable(caret::RMSE(dum1_results,tipsTest$tip),col.names = "RMSE")

#fit simple linear regression model
model_dum2 <- lm(tip ~ total_bill+factor(day) , data = tipsTrain)

dum2_results<-predict(model_dum2,tipsTest)
###compute fit
summary(model_dum2)


knitr::kable(caret::RMSE(dum2_results,tipsTest$tip),col.names = "RMSE")

```

```{r fancytable, echo=TRUE, results='asis'}
stargazer::stargazer(model_dum2,title="Fancy Reg Table",
          type = "html",
          float = TRUE,
          report = "vcs*",
          no.space = TRUE,
          header=FALSE,
          single.row = TRUE,
          #font.size = "small",
          intercept.bottom = F)
```

Regression Plot

```{r regplot4, echo=TRUE}

#create regression plot with customized style
ggplot(Combined_Tips,aes(x=total_bill, y=tip,color=Sample)) +
  geom_point(alpha=.5) +
  theme_minimal() +
  labs(x='total bill', y='tip', title='Linear Regression Plot') +
  theme(plot.title = element_text(hjust=0.5, size=20, face='bold')) +
  geom_abline(aes(slope=model_dum2$coefficients[[2]],
                  intercept=model_int$coefficients[[1]]),color="red")+
    geom_abline(aes(slope=model_dum2$coefficients[[2]],
                  intercept=model_int$coefficients[[1]]+model_dum2$coefficients[[3]]),color="red")+
  geom_abline(aes(slope=model_dum2$coefficients[[2]],
                  intercept=model_int$coefficients[[1]]+model_dum2$coefficients[[4]]),color="red")+
  geom_abline(aes(slope=model_dum2$coefficients[[2]],
                  intercept=model_int$coefficients[[1]]+model_dum2$coefficients[[5]]),color="red")
  
```

Residual Plot

```{r resid4, echo=TRUE}

#create residuals
testwithpred4<-as.data.frame(cbind(dum2_results,tipsTest))
#create residuals
testwithpred4<-testwithpred4%>%
  rename(prediction=dum2_results)%>%
  mutate(error=tip-prediction)

#create regression plot with customized style
ggplot(testwithpred4,aes(x=total_bill, y=error)) +
  geom_point(alpha=.5,color="deepskyblue") +
  theme_minimal() +
  labs(x='Total Bill', y='Error', title='Regression Error Plot') +
  theme(plot.title = element_text(hjust=0.25, size=20, face='bold')) +
  geom_hline(yintercept=0,color="red",linetype="dashed")
```

## [Interpreting the coefficients?](https://www.statology.org/how-to-interpret-regression-coefficients/)

## Exercise 3

1.  We used multi-variate linear regression to predict the `tip` feature from the `total_bill` and categorical `day` features. Repeat this process, but use the `total_bill`, `size`, `sex`, and `time` features. Has the prediction performance improved, i.e., what is the RSquared and RMSE?
2.  Interpret 2 of the coefficients.

# K-Nearest Neighbor

By the end of this lesson, you will be able to

-   articulate the basic concepts behind the k-nearest neighbor algorithm,

-   apply k-nn, and

-   identify the class of tasks where this algorithm can be successfully applied.

In this lesson, we introduce one of the simplest machine learning algorithms, [**k-nearest neighbors**](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm) (k-nn), and demonstrate how to effectively use this algorithm to perform both classification and regression. This algorithm works by finding the $k$ nearest neighbors to a new instance, and using the features of these neighbors to predict the feature for the new instance. If the feature is discrete, such as a class label, the prediction is classification, while if the feature is continuous, such as a numerical value, the prediction is regression.

The k-nn algorithm is different than most other algorithms in several ways. First, the algorithm is a lazy learner in that no model is constructed. Instead, the predictions are made straight from the training data. Thus, caret doesn't build a model, it instead builds an efficient representation of the training data. Second, this algorithm is non-linear and non-parametric since no model is constructed.

To understand why this algorithm works, simply look at society in general. You likely live near people who are similar to you in income, educational level, and religious or political beliefs. These inherent relationships are often captured in data sets, and can thus be used by neighbor algorithms to make reasonable predictions. At its simplest, one neighbor is used, and the feature from this neighbor is used to make the prediction. As more neighbors are added, however, a descriptive statistic can be applied to the nearest neighbor features. Often this is the mode for a discrete prediction or the mean value for a continuous prediction, but other statistics can also be used. In addition, we can weight the statistic to account for the proximity of different neighbors. Thus, we may use a weighted mean for a regression prediction.

This lesson first introduces the underlying formalism of the k-nn algorithm, which includes a discussion of distance metrics and the *curse of dimensionality* before loading the Iris data that we will often use to introduce a new machine learning algorithm.

Next, we will demonstrate the k-nn algorithm by classifying the Iris data, including how to quantify the performance of the algorithm by using a confusion matrix and several standard performance metrics. Next, we look at how the k-nn hyperparameters affect the classifications results, which will be done by introducing the *decision surface*. Finally, we will demonstrate the k-nn algorithm by regressing a sampled function.

```{r knn setup, echo=TRUE,warning=FALSE,message=FALSE}
library(caret)
library(tidyverse)

```

```{r knn graph 1}

set.seed(1)

indxTrain <- createDataPartition(y = iris[, names(iris) == "Species"], p = 0.7, list = F)

train <- iris[indxTrain,]

train1<-train%>%
  filter(Species=="setosa")%>% 
  sample_n(10)
train2<-train%>%
  filter(Species=="versicolor")%>% 
  sample_n(10)
train3<-train%>%
  filter(Species=="virginica")%>% 
  sample_n(10)
graph_train<-rbind(train1,train2,train3)

test <- iris[-indxTrain,]

graph_test<-test%>%
  sample_n(1)

ggplot(data=graph_train,mapping = aes(x=Petal.Length,y=Petal.Width,color=Species))+geom_point(alpha=0.5) + 
   geom_point(data=graph_test, color="darkred", size=4) + theme(legend.title = element_blank())+ggtitle("Which are the closest 5 to the red dot?")+xlim(4.5,6)+ylim(1.5,2.5)+
  theme(plot.title = element_text(hjust=0.5, size=10, face='bold'))


knnModel <- train(Species ~.,
                  data = graph_train,
                  method = 'knn',
                  preProcess = c("center","scale"),
                  tuneGrid=data.frame(k=5))

predictedclass<-predict(knnModel,graph_test)

predictedclass

knnModel$finalModel

```

As shown in the previous plot, when a new datum is added (e.g., the large red point), the k-nn algorithm first identifies the $k$ nearest neighbors (in the example above this is five by default). Given these nearest neighbors, a statistical evaluation of their relevant feature is performed, and the result used to make the prediction for the new data point. The statistical evaluation can be simple, such as choosing the mode from a set of discrete classes, or more complex, such as choosing the weighted mean of the features from the nearest neighbors, where the weight might be determined by the relative distance of each neighbor from the datum of interest.

Fundamental to this algorithm is the concept of **distance**. To this point we have simply assumed the features used to define *neighbors* followed a standard Euclidean distance (i.e., normal spatial coordinates). While this is often the case, some problems require a different distance. The next subsection explores this concept in more detail.

### **Distance Measurements**

To determine neighbors, we must adopt a definition for the distance. Naively, we might think this is simple, we adopt the common concept of distance that underlies the Pythagorean theorem: $d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$ where $d$ is the distance between two-dimensional points $(x_1, y_1)$ and $(x_2, y_2)$ . However, this is really only true for data that follow a [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance) metric, such as points on a cartesian plot. This is not true for calculating other distances, even spatial ones, such as the distance a plane flies on a long-distance flight. Furthermore, many data likely require an alternative definition of distance. For example, currency data, categorical data, or text data all likely require different definitions for distance.

Some of the standard distance metrics in this module include:

-   [`euclidean`](https://en.wikipedia.org/wiki/Euclidean_distance): supports the standard concept of spatial distance, and is the `l2-norm`.

-   [`manhattan`](https://en.wikipedia.org/wiki/Minkowski_distance): restricts distance measurements to follow grid lines. This metric is sometimes referred to as the Taxi cab distance, since taxis must follow streets, which also gives rise to its formal name, *manhattan*, for the street grid on the island of Manhattan. This distance is also known as the `l1-norm`.

-   [`haversine`](https://en.wikipedia.org/wiki/Haversine_formula): calculates the distance travelled over the surface of a sphere, such as the Earth.

-   [`chebyshev`](https://en.wikipedia.org/wiki/Chebyshev_distance): assumes the distance is equal to the greatest distance along the individual dimensions.

-   [`minkowski`](https://en.wikipedia.org/wiki/Minkowski_distance): a generalization of the Manhattan and Euclidean distances to arbitrary powers.

### **Curse of Dimensionality**

In general, we strive to obtain as much data as possible to improve our model prediction. The additional data can take one of two forms: additional features, which increases the dimensionality of our data set, or additional instances, which increases the pool of data from which to draw training and testing samples. Additional instances impacts a machine learning process in a simple manner, more data requires more computational power for either storing the data, or to process the data more rapidly. Additional dimensions on the other hand, can introduce an additional complication that is known as the [*curse of dimensionality*](https://en.wikipedia.org/wiki/Curse_of_dimensionality).

At its simplest, the curse of dimensionality relates the density of training data to the performance of our machine learning algorithm. In order to ensure sufficient density of training data across a potential sample space, the quantity of training data must increase exponentially (or very rapidly) with each new dimension. Otherwise, we end up with a space that is poorly sampled by training data.

The 'curse of dimensionality' is the tendency for model accuracy to initially increase as the number of variables used increases, but then reach a limit where accuracy decreases --- the point where the model is overfit

Note that some algorithms are affected more strongly by the curse of dimensionality, especially techniques that rely on distance measurements. Thus, the k-nn algorithm can be strongly affected by this issue, which can be visualized by looking closely at the decision surfaces. To overcome the curse of dimensionality, one must either increase the amount of training data, or reduce the dimensionality by either identifying the most important features or deriving new features that contain most of the information.

```{r knn graph 2}

ggplot(data=train,mapping = aes(x=Petal.Length,y=Petal.Width,color=Species))+geom_point(alpha=0.5) + 
   geom_point(data=test, color="darkred", size=1) + theme(legend.title = element_blank())+ggtitle("Knn for iris")+
  theme(plot.title = element_text(hjust=0.5, size=10, face='bold'))
```

## **k-Nearest Neighbors: Classification**

We can now apply the k-nn algorithm to the Iris data to create a classification model. The steps are demonstrated in the following code cell, where we create our estimator, fit the estimator to our training data, and generate a performance score on the testing data. Note that by default, the classification from the features of multiple neighbors is done by a simple majority vote (which is equivalent to the mode of the discrete labels). Finally, if multiple neighbors are at the same distance but have different labels, the ordering of the trading data will impact which label is used in the voting process.

```{r knn model 1}
set.seed(1)

indxTrain <- createDataPartition(y = iris[, names(iris) == "Species"], p = 0.7, list = F)

train <- iris[indxTrain,]
test <- iris[-indxTrain,]

# Fit the model on the training set
#set.seed(123)
knn_model_2 <- train(
  Species ~., 
  data = train, 
  method = "knn",
  trControl = trainControl("cv", number = 10),
  preProcess = c("center","scale"),
  tuneLength = 10
  )
knn_model_2
# Plot model error vs different values of k
plot(knn_model_2)
# Best tuning parameter k that minimize the error
knn_model_2$bestTune
# Make predictions on the test data
predictions <- predict(knn_model_2,test)
head(predictions)
# Compute the prediction error 
confusionMatrix(predictions, test$Species)

```

## Exercise 4

Use the code chunk above and answer the following questions.

1.  Change the data split size from 70/30 to 50/50. How does that effect the results?
2.  What was the optimal number of neighbors from number 1? Why do you think that is?
3.  Change the 10 to 5 in `trainControl("cv", number = 10)` and the 10 to 20 in `tuneLength = 10`. How did that change the results?

### **Performance Metrics**

In our Iris data classification example, we are performing a multiple classification task where we have more than two labels. As a result, one of the simplest ways to understand our performance is to create and display a [*confusion matrix*](https://en.wikipedia.org/wiki/Confusion_matrix). A confusion matrix has rows that correspond to the true labels and columns that correspond to the predicted labels. The elements of the confusion matrix contain the number of instances with true label given by the row index and the predicted label by the column index. A perfect classification, therefore, would have a confusion matrix populated entirely along the diagonal.

```{r}
# Compute the prediction error 
confusionMatrix(predictions, test$Species)
```

While the confusion matrix provides a useful visualization of the performance of a classification, in some cases a numerical score is desired. A number of different scores have been proposed for classification tasks, which one is most useful often depends on the nature of the classification task. Two commonly used scores are the [*precision* and the *recall*](https://en.wikipedia.org/wiki/Precision_and_recall). Note that both of these scores are ratios, and thus take values between zero (bad) and one (good).

Simply put, the precision (sometimes called the positive predictive value) is a measure of how many instances were correctly classified with the appropriate label. Thus, the precision is computed as the ratio of the number of instances correctly classified with a given label to the number of instances that actually have that label. Recall (sometimes called sensitivity) measures how many of the instances that were classified with a given label actually have that label. Thus, recall is computed as the ratio of correctly classified instances of a given label to the number of instances classified with that label.

To generate one single numerical score, the [*f1-score*](https://en.wikipedia.org/wiki/F1_score) was created, which is simply the harmonic mean of the precision and the recall (note, we must use the harmonic mean since these scores are actually ratios). Finally, one additional value of interest when interpreting these results is the *support*, which is the number of instances of each label in the testing set that was used to compute the indicated score.

### **k-Nearest Neighbors: Hyperparameters**

Machine learning algorithms often have tuning parameters that are extrinsic to the algorithm that cannot be determined directly from the data being analyzed. These parameters are formally known as hyperparameters. The k-nn algorithm has two hyperparameters: the number of nearest neighbors and a weighting scheme. To demonstrate how these hyperparameters affect the performance of the k-nn algorithm the following two subsections create a k-nn estimator with different values for these hyperparameters and display the results. To more effectively visualize the impact of these hyperparameters, we introduce the **decision surface**.

A decision surface is a visualization that shows a particular space occupied by the training data, in this case just the two dimensions: Sepal Width and Petal Width. The training data, color coded by their class, are displayed on this plot. In addition, the entire space spanned by the plot has been divided into a mesh grid, and each point in the mesh grid has been classified by the algorithm being analyzed. This has the effect of showing how new test data points would be classified as they move around the plot region. By comparing decision surfaces that correspond to different hyperparameter values, we can understand the corresponding change in the algorithm's performance.

```{r}

library(caret) 
data(iris)

indxTrain <- createDataPartition(y = iris[, names(iris) == "Species"], p = 0.7, list = F)

train <- iris[indxTrain,]
test <- iris[-indxTrain,]

knnModel <- train(Species ~.,
                  data = train,
                  method = 'knn')

pl = seq(min(test$Petal.Length), max(test$Petal.Length), by=0.1)
pw = seq(min(test$Petal.Width), max(test$Petal.Width), by=0.1)

# generates the boundaries for your graph
lgrid <- expand.grid(Petal.Length=pl, 
                     Petal.Width=pw,
                     Sepal.Length = 5.4,
                     Sepal.Width=3.1)

knnPredGrid <- predict(knnModel, newdata=lgrid)
knnPredGrid = as.numeric(knnPredGrid)

# get the points from the test data...
testPred <- predict(knnModel, newdata=test)
testPred <- as.numeric(testPred)
# this gets the points for the testPred...
test$Pred <- testPred

probs <- matrix(knnPredGrid, length(pl), length(pw))

ggplot(data=lgrid) + stat_contour(aes(x=Petal.Length, y=Petal.Width, z=knnPredGrid),bins=2) +
  geom_point(aes(x=Petal.Length, y=Petal.Width, colour=as.factor(knnPredGrid)))+
  geom_point(data=test, aes(x=Petal.Length, y=Petal.Width), size=3, alpha=0.75, color="darkred")+
  theme_bw()+ 
  labs(color = "Species")+
  ggtitle("Decision Surface")+
  scale_color_hue(labels=c('setosa', 'versicolor', 'virginica'))

```

#### **Neighbors**

As the number of neighbors increases, we tend to average over the distribution of training data, which makes the decision surface cleaner with smaller variations. Depending on the data being analyzed, this can be either a good or bad result.

#### **Weights**

The second hyperparameter that can be specified in the k-nn algorithm is the *weight* used to compute the statistical summary of the neighbor features. By default each neighbor is treated equally. The other simple choice for the weight hyperparameter is to use `distance` weighting, where the features from different neighbors are weighted by the inverse of their distance. Thus, closer points are weighted more than distant neighbors. Finally, the third option for this hyperparameter is to provide a user-defined function that accepts an array of distances and returns the appropriate weights. This last option enables an analyst to leverage one of the other distance metrics discussed.

## **k-Nearest Neighbors: Regression**

As is the case with many of the supervised learning algorithms the k-nn algorithm can be used for classification (as demonstrated previously) and for regression.

```{r knnreg}
set.seed(1)

indxTrain <- createDataPartition(y = iris[, names(iris) == "Sepal.Width"], p = 0.7, list = F)

train <- iris[indxTrain,]
test <- iris[-indxTrain,]

# Fit the model on the training set
#set.seed(123)
knn_model_3 <- train(
  Sepal.Width ~., 
  data = train, 
  method = "knn",
  trControl = trainControl("cv", number = 10),
  preProcess = c("center","scale"),
  tuneLength = 10
  )
knn_model_3
# Plot model error vs different values of k
plot(knn_model_3)
# Best tuning parameter k that minimize the error
knn_model_3$bestTune
# Make predictions on the test data
predictions <- predict(knn_model_3,test)
head(predictions)
# Compute the prediction error 
RMSE(predictions, test$Sepal.Width)

```

## Exercise 5

Use the code chunk above and answer the following questions.

1.  Change the data split size from 70/30 to 50/50. How does that effect the results?
2.  How is Knn regression different from knn classification?
3.  Change the 10 to 5 in `trainControl("cv", number = 10)` and the 10 to 20 in `tuneLength = 10`. How did that change the results?

## **Ancillary Information**

The following links are to additional documentation that you might find helpful in learning this material. Reading these web-accessible documents is completely optional.

1.  More details on code and knn <https://daviddalpiaz.github.io/r4sl/knn-class.html>

2.  Complete walk through <https://dataaspirant.com/knn-implementation-r-using-caret-package/>

3.  Another walk through <http://www.sthda.com/english/articles/35-statistical-machine-learning-essentials/142-knn-k-nearest-neighbors-essentials/>

Fin
